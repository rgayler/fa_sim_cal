---
title: "Central Idea"
author: "Ross Gayler"
date: "2020-11-29"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
bibliography: references.bib
---

This document explains the central idea behind the project.

## Problem setting

The problem concerns [entity resolution](https://en.wikipedia.org/wiki/Record_linkage) - determining whether multiple records, each derived from some entity, refer to the same entity. For concreteness, we consider a database lookup use case. That is, given a query record (corresponding to an entity) and a dictionary of records (corresponding to unique entities) we want to find the dictionary record (if any) that corresponds to the query record.

We introduce some more formal notation before considering the implications of the problem setting.

There is a universe of entities, $e \in E$. For example, the entities might be persons. Each entity has a unique identity, $id(e)$, that is not accessible to us.

There is a dictionary (database) of records, $d \in D$, each corresponding to an entity. Overloading the meaning of $id()$, we denote the identity of the entity corresponding to a dictionary record as $id(d)$. This identity of the entity corresponding to a dictionary record is not available to us.

We assume that the dictionary records correspond to unique entities, $id(d_i) = id(d_j) \iff i = j$. In general, the dictionary $D$ only correspond to a subset of the entities.

There is a set of query records, $q \in Q$. Once again, overloading the meaning of $id()$, we denote the identity of the entity corresponding to a query record as $id(q)$. The set of queries $Q$ is assumed to be representative of the queries that will be encountered in practice.

Each dictionary record is assumed to be the result of applying some observation process to an entity, $d_i = obs_d(e_i)$. Likewise, each query record is assumed to be the result of applying some observation process to an entity, $q_j = obs_q(e_j)$. The observations are usually taken to be tuples of values, e.g. $(name, address, age)$. This is not strictly necessary, but is convenient and will be adopted here. Note that the dictionary and query observation functions are different and may have different codomains. For convenience, we only consider the case where both observation functions have the same codomain.

If the identities were accessible to us we could define the lookup function $lookup(q, D) = \{ d \in D : id(d) = id(q) \}$, which is guaranteed to return either a singleton set or the empty set. Unfortunately, the identities are not accessible to us to use in $lookup()$. Instead, we are forced to define the lookup function in terms of the observation values, which are not guaranteed to uniquely identify the entities. The interesting characteristics of this problem arise from attempting to use the observation values as a proxy for identity.

Note that the lookup process can be described with respect to a single query $q$. We aim to define $lookup()$ to be as accurate as possible for every specific query $q$. The set of queries $Q$ is only relevant in so far as we will summarise the performance of $lookup()$ over $Q$ in order to make claims about the expected performance over queries.

## Probability of identity

Given that we don't have access to identity, the general approach taken in this field is to assess the *compatibility* of each pair of query and dictionary records, where $compat(q_i, d_j)$ is defined in terms of the observed values $q_i$ and $d_i$. (Remember, $q_i = obs_q(e_i)$ and $d_j = obs_d(e_j)$.)

## Similarity

## Calibrated similarity

## Subpopulation calibration

## Combining calibrated similarity

A test citation: [@langeFrequencyawareSimilarityMeasures2011]

# References
