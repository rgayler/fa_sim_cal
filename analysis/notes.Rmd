---
title: "Notes"
author: "Ross Gayler"
# date: "2021-01-05"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
  markdown: 
    wrap: 72
---

```{r setup}
# Don't echo the chunk code in these notes
knitr::opts_chunk$set(include = FALSE)

library(DiagrammeR)
```

This document is for keeping notes of any points that may be useful for
later project or manuscript development and which are not covered in the
analysis notebooks or at risk of getting lost in the notebooks.

# Project infrastructure

-   Consider using the [targets](https://wlandau.github.io/targets/)
    package to control the computational workflow.

# Entity data

-   Get a sizeable publicly available data set with personal names
    (NCVR).

    -   The focus of the empirical work is on string similarity metrics
        of names.

-   Use sex and age in addition to personal names so that most records
    are discriminable.

    -   High frequency names will likely not be discriminable with only
        these attributes.

        -   This is not a problem because we are really interested in
            whether the methods proposed here assist in quantifying the
            discriminability of records. We want records spanning a wide
            range of discriminability.

    -   Age (and possibly sex) will be used as a blocking variable.

        -   Blocking is probably needed to make the project
            computationally tractable.

    -   Age and sex are also of interest in the calculation of name
        frequency because name distributions should vary conditional on
        age and sex.

-   Keep address and phone number as they may be useful for manually
    checking identity in otherwise nondiscriminable records.

    -   As a fallback position, address and phone number can be used as
        discriminating attributes in the compatibility model.

-   Get the oldest available data to minimise it's currency (NCVR 2005
    snapshot).

-   Drop objectionable attributes such as race and political
    affiliation.

-   A note about the irregularity of names:
    <https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/>

# Entity data preparation

-   Apply basic data cleaning to the predictive attributes.

    -   This is probably unnecessary given how the data will be used.

    -   I can't bring myself to model data without scrutinising it
        first.

-   Only keep records that are ACTIVE and VERIFIED for modelling.

    -   These are likely to have the highest data quality attributes.

    -   These are least likely to have duplicate records (i.e. referring
        to the same person).

# Blocking

-   Use blocking to reduce the number of comparisons, to keep the
    computational cost feasible.

-   This project is not an operational system and we are only using
    blocking to reduce the computational cost, so we can choose blocking
    that would not be acceptable for an operational system.

-   Where the dictionary blocks vary widely in size we might choose to
    work with only a subset of blocks that are a suitable size.

-   If we think that some aspect of the compatibility modelling might
    vary as a function of block size we would probably want to test this
    over a wide range of block sizes.

-   We will probably be repeating analyses over some number of blocks to
    assess the variability of results, but that might only be a subset
    of blocks with no commitment to examine *all* the blocks.

-   Blocking variables may have missing values in the query and
    dictionary records.

    -   This can be handled but is fiddly and not the focus of this
        project.
    -   Handling missing *predictor* values in regression-based
        compatibility models is simple.

-   Exclude records with missing values on the blocking records from
    use, so that missing values don't have to be allowed for in
    blocking.

-   Try to choose blocking variables with a small proportion of missing
    values, so as to minimise systematic bias due to their exclusion.

-   Construct a few potentially useful blocking variables.

-   Blocking can induce changes in the distributions of names.

    -   Blocking on sex (in combination with other variables) will
        definitely give more homogeneity of first names within blocks
        because of gendered names.

    -   Blocking on age will give more homogeneity of first names within
        blocks because of name popularity varying over time.

    -   Blocking on county *may* give more homogeneity of last names
        within blocks because of families living together.

# Entity data characterisation

These sections are about looking at the properties of the entity data
that will be most relevant to their use in the compatibility models.

## Structure induced by equality

-   Prior work on name frequency has (implicitly) only considered
    equality of names. That is two name tokens are either absolutely
    identical or absolutely different. (No gradations of difference are
    entertained.) Counting the frequency of names is finding the
    cardinality of each set of identical name tokens.

    -   Name frequency will be used as a predictor in a compatibility
        model, $compat(q, d_i)$.
    -   For a query record $q$ the compatibility will be estimated for
        every dictionary record $d_i$ in the block $B_q$ (the set of
        dictionary records in the block selected by the query).
    -   The estimated compatibility will vary over $d_i$, so we expect
        the predictors to be functions of $d_i$ (in the context of the
        set of dictionary records, $B_q$ selected by the query record.)
    -   The (first attempt at) name equality frequency $f_{eq}(q, d_i)$
        is defined as
        $\vert \{ d_j : d_j \in B_q \land name(d_j) = name(d_i)\} \vert$.

-   Look at frequency distributions of names conditional on name length.
    The Zipf distributions may have different shape parameters for
    different name lengths. Name length might be examined as an
    alternative to name frequency for interaction with similarity.

-   Look at frequency distributions of names conditional on age and/or
    sex.

    -   These conditional distributions may increase the predictive
        power of the compatibility model.

-   Look at frequency distributions of names conditional on blocking
    variables.

    -   This is to get an understanding of the effect of blocking on
        name frequency distributions.
    -   In particular, look at any effects of block size (which has a
        very wide range).
    -   The anticipated usage is that name frequency will be calculated
        within the dictionary block selected by the query record. (The
        block can be construed as the only dictionary that matters for
        the purposes of the query.)

## Structure induced by similarity

-   The similarity version of name frequency is an extension of the
    equality version. It counts the number of dictionary records in the
    block that are at least as similar to the query record as the
    currently considered dictionary record.

    -   The (first attempt at) name similarity frequency
        $f_{sim}(q, d_i)$ is defined as
        $\vert \{ d_j : d_j \in B_q \land sim(name(q), name(d_j)) \ge sim(name(q), name(d_i))\} \vert$.

-   Look at similarity frequency distributions of names. It's not
    obvious that these should be Zipf distributions. For example, the
    rare names might be quite similar to more frequent names, which
    might obscure the long tail of the underlying distribution of names.

-   Look at similarity frequency distributions of names conditional on
    name length. The Zipf distributions may have different shape
    parameters for different name lengths.

    -   This is of interest because similarity is usually scaled to be
        between 1 (equality) and 0 (completely different) regardless of
        the string length. The longer the strings the greater the size
        of the space of possible strings and the higher the
        dimensionality of the space. It's not obvious to me that
        equality (inequality) of very short strings carries the same
        evidential value as equality (inequality) of long strings.

-   Look at similarity frequency distributions of names conditional on
    age and/or sex.

    -   These conditional distributions may increase the predictive
        power of the compatibility model.

-   Look at similarity frequency distributions of names conditional on
    blocking variables.

    -   This is to get an understanding of the effect of blocking on
        name frequency distributions.
    -   In particular, look at any effects of block size (which has a
        very wide range).

# Sampling

-   Both modelling and performance evaluation will be based on random
    samples of the entity data, so sort out the sampling first.

-   Modelling is necessarily based on query/dictionary record pairs.
    That is, the record pair is the unit of analysis.

-   Performance assessment of calibration will also be at the record
    pair level.

-   Performance assessment of overall model performance (e.g. AUC or
    F-score) is at the query record level, because these are calculated
    by aggregation across dictionary records corresponding to each query
    record.

-   However, the query/dictionary record pairs are generated as
    combinations of a set of queries with a fixed dictionary. The record
    pairs can't be independently sampled because that wouldn't respect
    the dictionary. That is, we need to create dictionaries by some
    sampling process and create a set of queries by some sampling
    process, and those two sets of records will jointly determine the
    query/dictionary record pairs that are in-sample.

-   We need some sort of training/testing partition to keep performance
    assessment honest.

-   Remember that queries are run against a dictionary, so in principle,
    it would be possible to have separate test/train queries run against
    one fixed dictionary.

    -   I am inclined to think that running training/testing queries
        against the same dictionary is probably OK because in a
        practical application the modelling would be done with respect
        to the dictionary as it existed at some point in time and then
        queries applied against essentially the same dictionary. (Given
        a large dictionary, subsequent queries would update it
        relatively slowly.)

    -   On the other hand, I am inclined to think that using separate
        dictionaries for training/test would not cause a problem,
        because the proposed models are not intended to rely on the
        actual names, but properties of the names (like frequency and
        length), which are likely to be very similar for different
        dictionaries based on random samples of the universe of names.

    -   On balance, I think I will have different dictionaries for
        train/test because it is probably harmless, probably
        conservative with respect to performance assessment, and
        probably easy to implement.

-   Dictionaries are constructed from entity data records, so having
    separate train/test dictionaries implies partitioning the entity
    data records prior to constructing the dictionaries.

    -   The easiest way to partition the records is to partition independently at the record level.

        -   Note that common names will occur in both data sets (train and test).

    -   Partitioning the entity records so that each name type occurred
        in only one of the train or test data sets would be the most conservative in terms of separation of the train and test data sets.
        - This would be easy if
        there was only one name field. However, we have three name
        fields (first, middle, last). Partitioning the data so that all
        the names occurred in only one data set would drastically reduce
        the number of records able to be used and bias the data towards
        names that only occur once (because it is impossible for those
        names to occur in two data sets).

    -   Partition the data at independently into

```{r sampling_diagram, echo=FALSE}
grViz("
digraph sampling_diagram {

node [shape = square, fixedsize = true, fontsize = 6]

total  [label = 'total data set', style = filled, fillcolor = gray]

tt_1  [label = 'train/test\nsplit 1', shape = triangle]
tt_2  [label = 'train/test\nsplit 2', shape = plaintext]
tt_k  [label = 'train/test\nsplit ', shape = plaintext]

total -> {tt_1 tt_2 tt_k}

train [label = 'train\nuniverse', style = filled, fillcolor = gray]
test  [label = 'test\nuniverse', style = filled, fillcolor = gray]

tt_1 -> {train test}

qry_samp [label = 'query\nsampler', shape = triangle]
ds_90    [label = 'dictionary\nsplit 90:10', shape = triangle]
ds_70    [label = 'dictionary\nsplit 70:30', shape = plaintext]
ds_50    [label = 'dictionary\nsplit 50:50', shape = plaintext]
ds_30    [label = 'dictionary\nsplit 30:70', shape = plaintext]
ds_10    [label = 'dictionary\nsplit 10:90', shape = plaintext]

train -> {qry_samp ds_90 ds_70 ds_50 ds_30 ds_10}

qry   [label = 'queries', style = filled, fillcolor = gray]

qry_samp -> qry

dict [label = 'dictionary', style = filled, fillcolor = gray]
comp [label = 'complement', style = filled, fillcolor = gray]

ds_90 -> {dict comp}

}
")
```

# Modelling

-   Try indicators for missingness. Missingness may be differentially
    informative across different predictor variables.

-   Try indicators for similarity == 1. The compatibility of exact
    string equality is not necessarily continuous with the compatibility
    of similarity just below 1.

-   Try name frequency as an interactive predictor variable.

    -   Also consider frequency conditional on age and/or sex

-   There are *two* names in each lookup: dictionary and query.
    Therefore there are also two name frequencies to be considered.

    -   We are interested in calculating the probability of a correct
        match for each query, so the sought probability is conditional
        on the query. Consequently the conditional probability of a
        correct match should *not* depend on the frequency of the query
        name.

    -   I am not entirely convinced by that argument, so consider how to
        use *both* frequencies (e.g. min, max, geometric mean, ...).

    -   Queries may contain names that do not exist in the dictionary,
        so we need to deal with that case.

    -   Do we need to apply frequency smoothing, as used in
        probabilistic linguistic models?

    -   Do we need to estimate the probability mass of unobserved names?

-   In general, the dictionary will be a subset of the entities in the
    universe of queries. Consider the impact of this on modelling as the
    fraction of the query universe in the dictionary varies.

    -   Can the sampling fraction be modelled as a prior probability
        (effectively, a change in the intercept term of a logistic
        regression)?

        -   This can be investigated by varying the fraction of
            dictionary records randomly sampled from the universe and
            treating the sampling fraction as a predictor in the model.
            The fitted coefficients for the sampling fraction can be
            compared to what would be expected treating the same
            sampling probabilities as a prior for the logistic
            regression.

        -   

    -   Consider whether this varies on a per query basis because of
        blocking. That is, is there effectively a separate dictionary
        per blocking value?

    -   Consider using the same variable for blocking and as a predictor
        to compare the effect on estimated probability of identity match
        as a function of dictionary fraction.

        -   It is feasible to use the "same" variables for blocking and
            as predictors. The blocks are based on the values of the
            dictionary records and selected by the value in the query
            record. The predictor variables are properties of record
            *pairs* - so there will still be within-block variance of
            the predictor even when there is no within-block variance of
            properties of the query record. That is, they're not the
            "same" variable when they are used for blocking and as a
            predictor.

# Performance evaluation

-   Performance evaluation should always be performed on a disjoint set
    of records from those used in estimation of the model.

    -   The obvious (and probably best) way to partition the data is to
        randomly select records. This means that for more frequent
        names, the same name will appear in the fitting and testing
        sets. So, if the model is in some sense "learning" details of
        individual names, this knowledge will be carried over from the
        fitting to testing sets and the performance of the model will be
        overstated.

    -   An alternative approach would be to partition the name types (as
        opposed to tokens). This would ensure that the names in the
        fitting and testing sets were completely disjoint, completely
        excluding any possibility of name-specific information being
        carried from fitting to testing.

        -   This would be easy if there were only one name field, but
            there are three. Partitioning name types in the most obvious
            way and making a 50:50 partition on each name field would
            mean that only 1/8 of records would be in the fitting set
            and 1/8 in the test set. This may make the data sets
            uncomfortably small.

-   Partition the entity data records into a dictionary and a set of
    queries (the $Q_U$ set).

    -   By the (reasonable) assumption that there are no duplicate
        records, each of the $Q_U$ queries will be unmatched in the
        dictionary.

-   Select a subset of the dictionary records to use as the $Q_M$ query
    set.

    -   By the (reasonable) assumption that there are no duplicate
        records, each of the $Q_M$ queries will have exactly one
        matching record in the dictionary.

-   This is evaluation is different to the usual evaluation of entity
    resolution in that it doesn't consider the impact of
    transcription/typographical variation in the queries.

    -   It looks at the quantification of discriminability when the
        available attributes are not necessarily able to ensure that all
        records are discriminable.

-   If we are interested in the performance with respect to
    transcription/typographical variation we may need to consider
    artificially corrupting some of the queries.

-   Consider assigning some of the dictionary records to randomly chosen
    wrong blocks. (Is this equivalent to randomly selecting some
    out-of-block query records to run against each dictionary block?)

# Writing/theory

-   Note relationship to Fellegi & Sunter / probabilistic record linkage
    (in proposal?).

## Quantity to be modelled

-   The unit of analysis is a dictionary/query record pair.

-   The logistic regression model is modelling the probability that the
    dictionary record refers to the same entity as the query record.

    -   That is, the record-pair modelling yields an unconditional
        probability that does not depend on how that predicted
        probability will be used (e.g. compared to a threshold).

    -   However, the logic behind the name frequency induced by
        similarity *does* appear to incorporate a dependence on usage.
        The frequency is calculated as the sum of the frequncies of the
        names (in the same block) that have similarity to the query name
        greater than or equal to the query similarity to the dictionary
        name being considered. This is based on an implicit *ceteris
        paribus* usage of similarity: If I were to accept this
        particular name as indicating an entity match, then logically I
        should also accept all other names that are at least as similar.

        -   The name frequency induced as equality can be construed as
            compatible with this definition by interpreting equality as
            a degenerate similarity relation.

        -   Is this a reasonable argument?

        -   Should this implied comparison across names within block be
            incorporated somehow in the mathematical formulae?

            -   This feels like it ought to be notated as a conditional
                probability (i.e. conditional on the dictionary record
                being accepted as a match) rather than an unconditional
                probability.

## Blocking

-   It might be possible to develop (or at least explain) most of the
    maths in terms of blocking.

-   Start with a universe $E$ of entities with the queries drawn
    uniformly at random from that universe and the dictionary being
    identical to the universe.

-   In the absence of any other information, the probability of each
    dictionary element being an identity match with the query is \$ 1 /
    \|E\| \$.

-   If the dictionary $D$ is a proper subset of $E$ it can be thought of
    as a (not very informative) block. That is, a block can be thought
    of as the dictionary induced by the query record.

-   If $D$ is a random subset of $E$, and in the absence of any other
    information, the probability of each dictionary element being an
    identity match with the query is $(|D| / |E|) / |D| = 1 / |E|$.

-   $|D|$ is the block size of the dictionary construed as a block. In
    the absence of any information to discriminate between records in
    the block, the larger the block, the lower the probability the any
    block record is the identity match to the query record.

-   $|D| / |E|$ is the probability that the entity corresponding to the
    query record is in the dictionary/block, given that the dictionary
    is a uniform random subset of the universe of entities.

-   Consider the other extreme, where blocking is perfect. That is, the
    entity query record is guaranteed to be in the dictionary. In this
    case the blocking is very informative (not a random selection from
    the universe of entities). The probability that the correctly
    matching entity record is in the block is 1, and the probability of
    each dictionary/block element being an identity match with the query
    is $1 / |D|$.

    -   That is, with perfect blocking, the probability of each entity
        being the identity match depends only on the block size.

    -   Where blocking is based on, say, name, the block size is the
        frequency of the name in the dictionary.

    -   Where blocking is less then perfect the probability that the
        entity corresponding to the query record is contained in the
        block will be less than 1.

-   This suggests that the probability of each record in the block being
    the correct match could be calculated as the product of conditional
    probabilities:

    $$ P(id(q) = id(d_i)) = P(id(q) = id(d_i) | d_i \in B_j) P(d_i \in B_j | d_i \in D)  P(d_i \in D) $$

-   What we need are models to estimate those component probabilities. I
    suspect that the cardinalities of those blocks would be very strong
    predictors of the probabilities. If the blocks are defined in terms
    of equality of names then the name frequencies determine the block
    cardinalities.

-   If there were multiple independent blockings, the probability of
    correct match of each record in the intersection of the blocks id
    the product of the probabilities associated with each block. This is
    equivalent to naive Bayes and shows the equivalence between
    construing the problem as a multivariate regression and construing
    it as using multiple blocking variables.

    -   Using regression rather than naive Bayes allows compensating for
        the blocking variables not being independent.
