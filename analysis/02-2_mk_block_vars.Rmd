---
title: "02-2_mk_block_vars"
subtitle: "Make blocking variables"
author: "Ross Gayler"
date: "2021-01-24"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
  markdown: 
    wrap: 72
---

```{r setup}
# Set up the project environment, because each Rmd file knits in a new R session
# so doesn't get the project setup from .Rprofile

# Project setup
library(here)
source(here::here("code", "setup_project.R"))

# Extra set up for the 02*.Rmd notebooks
source(here::here("code", "setup_02.R"))

# Extra set up for this notebook
# ???

# start the execution time clock
tictoc::tic("Computation time (excl. render)")
```

# Introduction

This notebook (`02-2_mk_block_vars`) constructs the potential blocking
variables identified in the previous notebook:

-   (sex, age)
-   (age, county)
-   (sex, age, county)

Show the assumed range of useful block sizes.

```{r}
# Arbitrary lower and upper bound on useful block size
# These are set in setup_02.R
blk_sz_min
blk_sz_max
```


# Read data

Read the usable data. Remember that this consists of only the ACTIVE &
VERIFIED records.

```{r}
# Show the entity data file location
# This is set in code/file_paths.R
fs::path_file(f_entity_cln_fst)

# get entity data
d <- fst::read_fst(
  f_entity_cln_fst,
  columns = c("sex", "age_cln", "age_cln_miss", "birth_place", "county_id")
  ) %>% 
  tibble::as_tibble()

dim(d)
```

# Missing values

Identify the missing values in the blocking variables and flag those
records as exclusions for blocking and modelling.

Sex and age have missing values, county ID does not.

```{r}
# updating d is probably poor form
# but I am only adding variables, so it is idempotent
d <- d %>% 
  dplyr::mutate(
    excl_blk_age_county_miss = age_cln_miss,
    excl_blk_sex_age_miss = sex == "UNK" | age_cln_miss,
    excl_blk_sex_age_county_miss = sex == "UNK" | age_cln_miss
  )

d %>% 
  dplyr::select(starts_with("excl_blk_")) %>% 
  summary()
```

-   (age, county) excludes \~31k (\~0.8%) of records from blocking and
    modelling.
-   (sex, age) and (sex, age, county) excludes \~47k (\~1.1%) of records
    from blocking and modelling.

# (sex, age)

There are only 4 blocks in (sex, age) that are too small. This can be
fixed with a small amount of age pooling.

The 17 year old and oldest age groups are the smallest, so they will
need pooling with other age groups.

The ordering of age is meaningful, so only pool adjacent ages (in order
to maintain the meaningfulness of the ordering).

Age will be combined with sex, so it is the size of the combined (sex,
age) blocks which is relevant.

The distribution of age is likely to be different for males and females.
We could have different pooling of age for males and females. However,
for simplicity I will use the same pooling of age for males and females.

Look at the distribution of block sizes for the relevant age groups.

```{r}
d %>% 
  dplyr::filter(!excl_blk_sex_age_miss &
                  (age_cln <= 20 | age_cln >= 95)) %>%
  with(table(age_cln, sex))
```

-   Pool the 17 year olds with the 18 year olds

-   Pooling 102 with 103 would be adequate.

    -   However the spikes of records at 101 and 104 are somewhat
        suspect. So I will pool all the records with ages over 100 in
        order to put all the questionable records in the one block.

```{r}
# updating d is probably poor form
# but I am only adding variables, so it is idempotent
d <- d %>% 
  dplyr::mutate(
    blk_age = dplyr::case_when(
      excl_blk_sex_age_miss  ~ NA_integer_, # make value NA for safety
      # code using NA is likely to fail if I forget to exclude these cases
      age_cln == 17          ~ 18L, # map 17 to 18
      age_cln >= 101         ~ 101L, # map all ages >= 101 to 101
      TRUE                   ~ age_cln # all ages < 101, accept as is
    ),
    # create the new combined blocking variable
    blk_sex_age = dplyr::if_else(excl_blk_sex_age_miss,
                                 NA_character_, # make value NA for safety
                                 paste(sex, blk_age, sep = ":")
    )
  ) %>% 
  dplyr::select(-blk_age) # we won't use age alone as a blocking variable

# look at the distribution of block sizes for (sex, age)
d %>% 
  dplyr::filter(!excl_blk_sex_age_miss) %>% 
  dplyr::count(blk_sex_age, name = "blk_sz") %>% 
  ggplot(aes(x = 0, y = blk_sz)) +
  geom_hline(yintercept = c(blk_sz_min, blk_sz_max), colour = "blue") +
  geom_jitter(width = 0.35, alpha = 0.2) +
  geom_boxplot(outlier.shape = NA, colour = "red", alpha = 0.0) +
  scale_y_log10(n.breaks = 7) + annotation_logticks(sides = "l") +
  theme(panel.grid.minor.y = element_line(),
        panel.grid.major.x = element_blank(),  panel.grid.minor.x = element_blank(), 
        axis.title.x = element_blank(), axis.ticks.x = element_blank(), axis.text.x = element_blank()) +
  coord_fixed(ratio = 2)
```

# (age, county)

# (sex, age, county)

# Characterise blocking

Look at the distributions of block sizes for all reasonable combinations
of potential blocking variables.

-   Don't consider place of birth because the distribution of levels is
    too concentrated.
-   Only consider sex in combination with other variables, not in
    isolation.

```{r}
# Calculate all the block sizes for each combination of blocking variables.
# For only 6 combinations I will manually enumerate them.
d_blk <- dplyr::bind_rows(
  list(
    sex_age_cnty = dplyr::count( d, sex, age_cln, county_id, name = "blk_sz"),
    sex_age      = dplyr::count( d, sex, age_cln           , name = "blk_sz"),
    sex_cnty     = dplyr::count( d, sex,          county_id, name = "blk_sz"),
    age_cnty     = dplyr::count( d,      age_cln, county_id, name = "blk_sz"),
    age          = dplyr::count( d,      age_cln           , name = "blk_sz"),
    cnty         = dplyr::count( d,               county_id, name = "blk_sz")
  ),
  .id = "blk_vars"
) %>% 
  dplyr::mutate(
    blk_vars = forcats::fct_infreq(blk_vars)
  )

d_blk %>% 
  ggplot(aes(x = blk_vars, y = blk_sz)) +
  geom_hline(yintercept = c(blk_sz_min, blk_sz_max), colour = "blue") +
  geom_jitter(width = 0.4, alpha = 0.1) +
  geom_boxplot(outlier.shape = NA, colour = "red", alpha = 0.0) +
  scale_y_log10(n.breaks = 7) + annotation_logticks(sides = "l") +
  theme(panel.grid.major.x = element_blank(), panel.grid.minor.y = element_line())

d_blk %>% 
  ggplot(aes(x = blk_sz)) +
  geom_vline(xintercept = c(blk_sz_min, blk_sz_max), colour = "blue") +
  geom_histogram(aes(y = ..density..), bins = 10) +
  geom_density(colour = "orange") +
  scale_x_log10() +
  facet_grid(rows = vars(blk_vars))

# Characterise the blocking schemes
d_blk_summ <- d_blk %>% 
  dplyr::group_by(blk_vars) %>% 
  dplyr::summarise(
    n_blk = n(),
    n_rec = sum(blk_sz),
    
    min_blk_sz = min(blk_sz),
    max_blk_sz = max(blk_sz),
    
    n_blk_low = sum(blk_sz < blk_sz_min),
    p_blk_low = (n_blk_low / n_blk) %>% round(2),
    n_rec_low = sum(blk_sz[blk_sz < blk_sz_min]),
    p_rec_low = (n_rec_low / n_rec) %>% round(2),

    n_blk_high = sum(blk_sz > blk_sz_max),
    p_blk_high = (n_blk_high / n_blk) %>% round(2),
    n_rec_high = sum(blk_sz[blk_sz > blk_sz_max]),
    p_rec_high = (n_rec_high / n_rec) %>% round(2),
    
    n_blk_useful = sum(between(blk_sz, blk_sz_min, blk_sz_max)),
    p_blk_useful = (n_blk_useful / n_blk) %>% round(2),
    n_rec_useful = sum(blk_sz[between(blk_sz, blk_sz_min, blk_sz_max)]),
    p_rec_useful = (n_rec_useful / n_rec) %>% round(2),
    
    gm_useful_blk_sz = blk_sz[between(blk_sz, blk_sz_min, blk_sz_max)] %>% 
      log() %>% mean() %>% exp() %>% round() # geometric mean of useful block sizes
  )

# number of blocks
d_blk_summ %>% 
  dplyr::select(blk_vars, n_blk, n_blk_low, n_blk_high, n_blk_useful) %>% 
  knitr::kable(format.args = list(big.mark = ","))

# proportion of blocks
d_blk_summ %>% 
  dplyr::select(blk_vars, n_blk, p_blk_low, p_blk_high, p_blk_useful) %>% 
  knitr::kable(format.args = list(big.mark = ","))

# number of records
d_blk_summ %>% 
  dplyr::select(blk_vars, n_rec_low, n_rec_high, n_rec_useful) %>% 
  knitr::kable(format.args = list(big.mark = ","))

# proportion of records
d_blk_summ %>% 
  dplyr::select(blk_vars, p_rec_low, p_rec_high, p_rec_useful) %>% 
  knitr::kable(format.args = list(big.mark = ","))

# block size
d_blk_summ %>% 
  dplyr::select(blk_vars, min_blk_sz, max_blk_sz, gm_useful_blk_sz) %>% 
  knitr::kable(format.args = list(big.mark = ","))
```

-   county and age have too many blocks/records in the high block size
    range.

-   county and age have too few blocks/records in the low block size
    range.

-   (sex, age, county) and (age, county) have too few blocks/records in
    the high block size range.

-   The largest block sizes for (sex, age, county) and (age, county) are
    quite small relative to the upper limit of the useful block size
    range.

-   (sex, age, county) and (age, county) have too many blocks/records in
    the low block size range.

    -   This can be fixed by pooling the smallest levels of the
        individual variables.
    -   Small blocks can be made larger by pooling.
    -   Large blocks can not be made smaller without combining another
        blocking variable.

-   (sex, age) and (sex, county) have the highest proportion of usefully
    sized blocks.

-   (sex, age) has \~89% of blocks in the useful block size range.

    -   The blocks that are too small could be fixed by pooling ages.

-   (sex, age) has \~100% of records in useful sized blocks.

-   (sex, county) has \~82% of blocks in the useful block size range.

    -   \~4% of blocks (\~36% of records) are too large
    -   \~14% of blocks (\~0% of records) are too small
    -   The blocks that are too small could be fixed by pooling
        counties.

-   (sex, county) has only 64% of records in useful sized blocks.

**Conclusion**

My tentative conclusion is to use (sex, age) for blocking and to pool
the higher ages into groups to ensure that all block sizes are above the
lower limit of the useful block size.

I will also look at (sex, county) as a possible blocking variable by
pooling counties into groups to ensure that all block sizes are above
the lower limit of the useful block size.

# Timing {.unnumbered}

```{r echo=FALSE}
tictoc::toc()
```
